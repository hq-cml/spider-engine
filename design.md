# 开发文档：
### 整体架构如图：
![架构图](./img/spider-engine-struct.png)

### 概念解释：
	对于存储引擎，很多概念相对类似、通用，但又有些许区别，这里统一对齐一下。
- 文档：存储的基本单位，是一条结构化了的数据，对等的，可以理解为Mysql表中的一条记录。
- 倒排：SE的底层存储结构，一个文档的字符内容，被分词之后，会形成多个词条，倒排就是一种映射关系，Map：词条=>文档Id。有了这个倒排映射，那么搜索功能将变得简单高效。
- 正排：SE的底层存储结构，相对于倒排的逆映射，文档Id=>字段内容。这主要用于结果的过滤以及完整文档的生成，例如一个文档的所有字段的正排合在一起，就是一个完整的文档内容。
- 字段：文档的基本组成单位，一个文档由多个字段组成，这和Mysql中的概念是一致的。在spider-engine中，每个字段都会拥有一个正排；字符类型的字段，可以拥有倒排。
- 索引过程：将文档数据各个字段生成可供搜索的倒排索引和正排索引的过程就是索引过程。在spider-engine中，当增加一个文档后，这一过程将自动进行。
- 表：类比于Mysql的表，多个拥有相同字段定义的文档，组成一张表。
- 库：类比于Mysql的库，表的管理容器，多个表组成一个库。
- 分区：类比于Mysql的分区，底层的存储结构，整体表的一部分数据（为了将来分布式、数据容错、数据迁移等预留想想空间），本质上一个分区就已经拥有完整的索引套件：正排+倒排+字段。能够执行独立的搜索，最终的搜索结果其实是各个分区独立搜索结果的并集。
- 检索：即搜索，即给定一个关键词或一句话，针对某个字段进行搜索。通常还会伴有过滤和排序等操作。本质上底层会用到倒排索引+正排索引。

Mysql | ES | Spider-Engine
---|---|---
Database | Indexes| Database
Table| Index/Type| Table
Row| Document| Document
Column| Field| Field

### 倒排的实现：
根据搜索引擎的基本原理, 一个字段(列)需要支持搜索，那么其需要拥有一个倒排索引。
本倒排索引由一颗B+树和一个倒排文件搭配，宏观上可以看成一个Map（Key是分词后的各个Term，Val是Term对应的docId的列表）
其中：
	Key的部分基于B+树实现, 便于搜索和范围过滤。B+树我没有自己实现，而是采用了煮面的BoltDb，key是term, val则是term在倒排文件中的offset
    Val的部分基于mmap实现的倒排文件，mmap的好处在于可以快速隐射磁盘内容到内存，使得程序可以像操作内存一样读取文件，极大提升访问速度

倒排文件: 由mmap实现，顺序的数据块, 每块数据长这个个样子
[nodeCnt(8Byte)|nodeStruct1|nodeStruct2|....][nodeCnt(8Byte)|nodeStruct1|nodeStruct3|....]....
nodeStuct:{docId: xx, weight: xx}

### 正排的实现：
正排索引，提供一个docId=>字段内容的映射。
它的作用通常是用于字段信息的读取、最终查询结果过滤等方面。比如，一个文档的所有字段的正排索引合并，就是文档的完整内容。
因为正排索引的特点（key是docId，是一个数字），实现上利用数组（slice），下标作为docId, 数组元素值作为实际的值，所以这也可看做一种map。

Btw：
这里将docId作为key，是一种简化，实际上key是pos，pos的定义见下面分区实现解释。

### 字段的实现：
字段的概念，对等于Mysql中表的一列。一张表逻辑是有多个字段构成的（物理上还有一层分区，见下）
除了定义了字段本身信息，field的还有一个重要的作用，就是管理索引。在spider-engine中，一个field：
必然会包含一个正排索引：因为获取字段内容总是必须的
可选的一个倒排索引：如果字段不需要搜索，或者是数字、时间等数值型的字段，那么不会建立倒排索引

### 分区的实现：
分区, 类比于Mysql的分区的概念，所有的分区合在一起, 就是一张完整的表
每个分区是独立的索引单元, 能够进行索引
每个分区都拥有全量的filed（但是数据是整体表数据的一部分）
同一个分区中的各个字段的共用同一套正、倒排文件(btdb, ivt, fwd, ext)

Btw：
因为分区的这个特点（每个分区只是一部分的文档）所以正排索引的startDocId和nextDocId很重要，他们相当于分区的边界，左闭右开。
startDocId表示在当前分区索引的起始docId
nextDocId表示在当前分区下一个新增doc期望的Id
判断一个docId是否属于当前分区：startDocId <= docId < nextDocId
每个分区中，正排索引的key是pos = docId-startId


### 索引、字段、分区的状态：

*    在索引内存态通过memoryNum[]来引用
*    若磁盘态则通过baseMmap.Get(fwdOffset + (docId-startId)*DATA_BYTE_CNT)

 *
 *
 * 索引有两种状态：
 * 一种是内存态，此时索引存在于memoryNum或者memoryStr中，另一种是落盘态，此时分区分索引类型
 *   数字型：
 *          baseMmap当做一个[]int64数组来引用（每个元素占8个Byte）
 *   字符型：
 *          需要baseMmap和extMmap配合使用
 *          baseMmap当做一个[]int64数组来引用（每个元素占8个Byte），表示其在extMmap中的offset
 *          extMmap实际存string的内容，格式如： [len|content][len|content][len|content]...
 *
 * Note：
 *
 *

### 主键的实现：

### 跨字段搜索的实现：

### 分词的实现：
依赖jiebago和sego

### 排序：
默认使用文本相关性进行排序
